/*
 * player_task.c
 *
 *  Created on: Feb 6, 2017
 *      Author: okoc
 */

/*
 * TABLE TENNIS PLAYER
 *
 *
 *  Remarks:
 *
 *       1. The ball's state is generated by simulation (seeding rng).
 *       2. The cartesian des states at hitting time are calculated with models of ball
 *          racket and table in order to land the ball
 *          at a desired location : center of the opponent's court
 *          at a desired time
 *       3. Joint states of the hitting and returning trajectories are planned using polynomials.
 *       4. Planning (traj generation) is done online with NLOPT optimization
 *
 *	Multithreading:
 *
 *	     1. Optionally: Load from lookup table qf,qfdot,T
 *	     2. In a seperate thread run NLOPT to adjust qf,qfdot,T | q0,q0dot,b0,v0
 *	     3. During that time follow initial qf,qfdot,T from lookup if loaded
 *	     4. After (2) finishes, recalculate polynomial from current q0,q0dot, with T-Topt seconds
 *
 *  Created on: June 22, 2016
 *      Author: okoc
 */

#include "table_tennis_common.h"
#include "sl_interface.h"

void add_player_task( void );
static int change_player_task(void);
static int init_player_task(void);
static int run_player_task(void);
static void display_ball();
static void compute_torques();
static void check_safety();
static int goto_posture(int posture);
static int goto_center_posture();
static int goto_right_posture();
static int goto_left_posture();
static void print_des_state(SL_DJstate des_state[]);
static void print_filter_accuracy();
static void update_ball_obs();

#define NBLOBS 2

blob_state ball_obs[NBLOBS];

/*
 * Adds the task to the task menu
 */
void add_player_task( void ) {
	int i;
	char varname[30];

	addTask("PLAYER task", init_player_task, run_player_task, change_player_task);
}

/*
 * Changes task parameters
 */
static int change_player_task(void) {
	int i,j;
	return TRUE;
}

/*
 * Initialization for task
 *
 */
static int init_player_task(void) {

	int posture, ready; // flags
	bzero((char *)&(ball_obs[0]), NBLOBS * sizeof(ball_obs[0]));

	/* check whether any other task is running */
	if (strcmp(current_task_name,NO_TASK) != 0) {
		printf("Task can only be run if no other task is running!\n");
		return FALSE;
	}

	get_int("Use simulated ball?", FALSE, &simulation);
	if (simulation) {
		printf("Testing table tennis algorithms on the simulator...\n");
		get_int("Turn on SPIN MODE?\n", 0, &SIM_SPIN_MODE);
		reset_sim_ball();
	}

	/* go to a save posture */
	get_int("Which posture? 0 = CENTRE, 1 = RIGHT, 2 = LEFT.\n", 0, &posture);
	if (!goto_posture(posture))
		return FALSE;

	load_options();

	// for real setup
	setDefaultEndeffector();
	endeff[RIGHT_HAND].x[_Z_] = .3;

	/* ready to go */
	ready = 999;
	while (ready == 999) {
		if (!get_int("Enter 1 to start or anything else to abort ...",ready, &ready))
			return FALSE;
	}
	if (ready != 1)
		return FALSE;

	// turn on/off real time
	changeRealTime(TRUE);
	return TRUE;

}

/*
 * Runs the task from the task servo: REAL TIME requirements!
 *
 */
static int run_player_task(void) {

	// update blobs every 2ms (instead of every 20 ms)
	update_ball_obs();

	play(joint_state,ball_obs,joint_des_state);
	//cheat(joint_state,sim_ball_state,joint_des_state);

	// reset and draw ball in simulation
	display_ball();

	// compute torques based on inverse dynamics
	compute_torques();

	return TRUE;
}


/*
 * If in SIMULATION mode, update the blobs structure with
 * simulated ball positions every 2 ms
 *
 * else copy from the blobs
 *
 */
static void update_ball_obs() {

	int i;

	if (simulation) {
		ball_obs[1].status = TRUE;
		for (i = 0; i < 3; i++) {
			ball_obs[1].pos[i] = sim_ball_state.x[i+1];
		}
	}
	else {
		ball_obs[1].status = blobs[3].status;
		ball_obs[0].status = blobs[1].status;
		for (i = 0; i < 3; i++) {
			ball_obs[1].pos[i] = blobs[3].blob.x[i+1];
		}
		for (i = 0; i < 3; i++) {
			ball_obs[0].pos[i] = blobs[1].blob.x[i+1];
		}
	}
}

/*
 * Displays and resets the simulated ball in simulation.
 */
static void display_ball() {

	// for resetting
	static int firsttime = TRUE;
	static int reset_sim = FALSE;
	static double time_passed;
	static double time_last;

	if (firsttime) {
		firsttime = FALSE;
		time_last = get_time();
	}

	// calculate the racket orientation from endeffector
	calc_racket(&racket_state, &racket_orient, cart_state[RIGHT_HAND], cart_orient[RIGHT_HAND]);

	// resetting ball in simulation mode
	if(simulation) {
		simulate_ball(&sim_ball_state, &racket_state, &racket_orient, &reset_sim);
		time_passed = (get_time() - time_last)/1e6;
		if (reset_sim && time_passed >= 4.0) {
			reset_sim_ball();
			time_last = get_time();
			reset_sim = FALSE;
		}
		//display_pred_ball();
		display_sim_ball();
	}
	else {
		display_pred_ball();
	}
}

/*
 * Check the safety of the desired joint states explicitly
 * and then calculate the u_ff with inverse dynamics
 *
 * If friction compensation is turned on, then add some compensation on top of u_ff
 *
 */
static void compute_torques() {

	check_safety();

	// control the robot
	// calculate the feedforward commands with inverse dynamics
	SL_InvDyn(NULL, joint_des_state, endeff, &base_state, &base_orient);
	/*if (friction_comp) {
		addFrictionModel(joint_des_state);
	}*/

}

/*
 * Checks the safety of the calculated desired state
 * explicitly
 *
 */
static void check_safety() {

	if (!check_joint_limits(joint_state, SLACK)) {
		printf("Joint limits are exceeding limits! Freezing...\n");
		freeze();
	}
	if (!check_des_joint_limits(joint_des_state, SLACK)) {
		printf("Joint des limits are exceeding limits! Freezing...\n");
		freeze();
	}
	/*if(!check_range(joint_des_state)) {
		printf("Exceeding torque limits! Freezing...\n");
		freeze();
	}*/
	if (collision_detection(racket_state)) {
		printf("Collision with table detected!\n");
		freeze();
	}
}

/*
 * Initialize robot posture at right, center and left sides
 */
static int goto_posture(int posture) {

	if (posture == 1)
		goto_right_posture();
	else if (posture == 0)
		goto_center_posture();
	else if (posture == 2)
		goto_left_posture();
	else { // unrecognized input
		printf("Unrecognized posture. Quitting...\n");
		return FALSE;
	}
	return TRUE;
}

/*
 * Robot goes to a center posture
 */
static int goto_center_posture() {

	int i;
	bzero((char *)&(init_joint_state[1]), N_DOFS * sizeof(init_joint_state[1]));
	init_joint_state[1].th = 0.0;
	init_joint_state[2].th = 0.0;
	init_joint_state[3].th = 0.0;
	init_joint_state[4].th = 1.5;
	init_joint_state[5].th = -1.75;
	init_joint_state[6].th = 0.0;
	init_joint_state[7].th = 0.0;

	go_target_wait(init_joint_state);
		return FALSE;

	return TRUE;
}

/*
 * Robot waits on the right-hand side
 */
static int goto_right_posture() {

	int i;
	bzero((char *)&(init_joint_state[1]), N_DOFS * sizeof(init_joint_state[1]));
	init_joint_state[1].th = 1.0;
	init_joint_state[2].th = -0.2;
	init_joint_state[3].th = -0.1;
	init_joint_state[4].th = 1.8;
	init_joint_state[5].th = -1.57;
	init_joint_state[6].th = 0.1;
	init_joint_state[7].th = 0.3;

	go_target_wait(init_joint_state);
	if (!go_target_wait_ID(init_joint_state))
		return FALSE;
	return TRUE;
}

/*
 * Robot waits on the left-hand side
 */
static int goto_left_posture() {

	int i;
	bzero((char *)&(init_joint_state[1]), N_DOFS * sizeof(init_joint_state[1]));
	init_joint_state[1].th = -1.0;
	init_joint_state[2].th = 0.0;
	init_joint_state[3].th = 0.0;
	init_joint_state[4].th = 1.5;
	init_joint_state[5].th = -1.57;
	init_joint_state[6].th = 0.1;
	init_joint_state[7].th = 0.3;

	go_target_wait(init_joint_state);
	if (!go_target_wait_ID(init_joint_state))
		return FALSE;
	return TRUE;
}

/*
 * Print desired positions and velocities.
 *
 * Useful for debugging
 *
 */
static void print_des_state(SL_DJstate state[]) {

	int i;
	printf("Des state:\n");
	for(i = 1; i <= N_DOFS; i++) {
		printf("Pos: %f, Vel: %f\n", state[i].th, state[i].thd);
	}
}


/*
 * Prints the distance between the estimated state and the sim state.
 * a.k.a accuracy
 */
static void print_filter_accuracy() {

	printf("==========================================\n");
	printf("ballPred: x = [%.2f,%.2f,%.2f], xd = [%.2f,%.2f,%.2f]\n",
			ballPred.x[_X_],ballPred.x[_Y_],ballPred.x[_Z_],
			ballPred.xd[_X_],ballPred.xd[_Y_],ballPred.xd[_Z_]);
	printf("ballAct: x = [%.2f,%.2f,%.2f], xd = [%.2f,%.2f,%.2f]\n",
			sim_ball_state.x[_X_],sim_ball_state.x[_Y_],sim_ball_state.x[_Z_],
			sim_ball_state.xd[_X_],sim_ball_state.xd[_Y_],sim_ball_state.xd[_Z_]);

	double dist = 0.0;
	int i;

	for (i = 1; i <= N_CART; i++) {
		dist = dist + pow(ballPred.x[i] - sim_ball_state.x[i],2);
		dist = dist + pow(ballPred.xd[i] - sim_ball_state.xd[i],2);
	}
	printf("Dist of est. and act. = %f\n", sqrt(dist));

}



