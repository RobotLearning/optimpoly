\section{Flexible Player (FP)}\label{method}

In this section we present an algorithm that solves the optimal control problem introduced in ~\eqref{costFnc1} efficiently. Joint limits are included additionally as inequality constraints in the optimization. We call the resulting table tennis player $\Alg$ or $\alg$ for short. %$\jointMax, \jointMin \in \mathbb{R}^n$, 
%
\subsubsection*{\textbf{Nonlinear Constrained Optimization}.} As explained in the previous section, the optimal trajectories are third order polynomials in joint-space for each degree of freedom of the robot
%
\begin{align}
\joint_{\mathrm{strike}}(t) = \vec{a}_3 t^3  + \vec{a}_2 t^2 + \dot{\joint}_0 t + \joint_0, \ 0 \leq t \leq T,
\end{align}
%
\noindent where the coefficients of the polynomials can be parameterized in terms of final joint positions $\joint_f$, final joint velocities $\dot{\joint}_f$ and striking time $T$
%
\begin{align}
\vec{a}_3 &= \frac{2}{T^3}(\joint_0 - \joint_f) + \frac{1}{T^2}(\dot{\joint}_0 + \dot{\joint}_f), \\
\vec{a}_2 &= \frac{3}{T^2}(\joint_f - \joint_0) - \frac{1}{T}(\dot{\joint}_f + 2\dot{\joint}_0).
\label{coeffs}
\end{align}
%
That is, along with the striking time $T$ as a free parameter, we have a $2n+1$ dimensional optimization problem with nonlinear equality and inequality constraints. Rewriting the integrand (i.e. weighted sum of accelerations) in~\eqref{costFnc1} in terms of these free parameters and integrating over time, we get the following optimization algorithm
%
\begin{align}
\min_{\joint_f,\dot{\joint}_f, T} & \, 3T^3 \vec{a}_3^{\intercal}\vec{R}^{-1}\vec{a}_3 + 3T^2 \vec{a}_3^{\intercal}\vec{R}^{-1}\vec{a}_2 + T\vec{a}_2^{\intercal}\vec{R}^{-1}\vec{a}_2 \label{costFnc3} \\
\textrm{s.t. \ }
& \kin_p(\joint_f) = \ballPred(T), \\
& \kin_n(\joint_f) = \normal_{\mathrm{des}}(T), \\
&\jac(\joint_f)\dot{\joint}_f = \racketVel_{\mathrm{des}}(T), \\
& \jointMin \leq \joint_f \leq \jointMax, \label{jointLimPointwise}\\
& \jointMin \leq \joint_{\mathrm{ext}} \leq \jointMax \label{jointLimTraj}.
%& \jointMin \leq \joint_{\mathrm{strike}}(\vec{t}_{\mathrm{ext}}^{i}) \leq \jointMax, \, i = 1,2, \\
%& \jointMin \leq \joint_{\mathrm{return}}(\vec{t}_{\mathrm{ext}}^{i}) \leq \jointMax, \, i = 3,4,
\end{align}
%
The returning trajectories that bring the robot from striking joint positions $\joint_f$ to a fixed rest position $\joint_0$ in joint space can also be taken as third order polynomials
%
\begin{align}
\joint_{\mathrm{return}}(t) = \vec{\tilde{a}}_3 t^3  + \vec{\tilde{a}}_2 t^2 + \dot{\joint}_f t + \joint_f, \ 0 \leq t \leq \returnTime,
\label{returnTraj}
\end{align}
%
\noindent for a fixed return time $\returnTime$. The coefficients $\vec{\tilde{a}}_3, \vec{\tilde{a}}_2$ of~\eqref{returnTraj} are as in \eqref{coeffs} but with $\joint_0, \joint_f$ and $\dot{\joint}_0, \dot{\joint}_f$ reversed
%
\begin{align}
\vec{\tilde{a}}_3 &= \frac{2}{\returnTime^3}(\joint_f - \joint_0) + \frac{1}{\returnTime^2}(\dot{\joint}_f + \dot{\joint}_0), \\
\vec{\tilde{a}}_2 &= \frac{3}{\returnTime^2}(\joint_0 - \joint_f) - \frac{1}{\returnTime}(\dot{\joint}_0 + 2\dot{\joint}_f).
\label{returnCoeffs}
\end{align}
%
\subsubsection*{\textbf{Joint Limit Satisfaction}.} When optimizing \eqref{costFnc3} we enforce the final joint positions $\joint_f$ in~\eqref{jointLimPointwise} to respect the joint limits for each component. However, we need to ensure that the whole trajectory, including the striking and returning trajectories, are respecting the joint limits at all times. Third order polynomials can each have at most $2$ extrema $\joint_{\mathrm{ext}}$ in the interior of their domains, corresponding to the conditions $\dot{\joint}_{\mathrm{strike}}(t) = 0, \ \dot{\joint}_{\mathrm{return}}(t) = 0$. Therefore, checking the joint extrema candidates  $\joint_{\mathrm{ext}}$ in~\eqref{jointLimTraj} at times
% The last inequality constraints in~\eqref{jointLimTraj} correspond to the condition that the striking and returning polynomials should be feasible at all times.
%
\begin{align}
\upsilon_{j}^{1,2} = \frac{-a_{2,j} \ \rpm \ \sqrt{a_{2,j}^2 - 3a_{3,j}\dot{q}_{0,j}}}{3a_{3,j}}, \\
\upsilon_{j}^{3,4} = \frac{-\tilde{a}_{2,j} \ \rpm \ \sqrt{\tilde{a}_{2,j}^2 - 3\tilde{a}_{3,j}\dot{q}_{f,j}}}{3\tilde{a}_{3,j}},
%\vec{t}_{\mathrm{ext}}^{1,2}(j) = \frac{-\vec{a}_2(j) \rpm \sqrt{\vec{a}_2^2(j) - 3\vec{a}_3(j)\dot{\joint}_0(j)})}{3\vec{a}_3(j)}, \\
%\vec{t}_{\mathrm{ext}}^{3,4}(j) = \frac{-\vec{\tilde{a}}_2(j) \rpm \sqrt{\vec{\tilde{a}}_2^2(j) - 3\vec{\tilde{a}}_3(j)\dot{\joint}_f(j)})}{3\vec{\tilde{a}}_3(j)},
\label{jointPosExtrema}
\end{align}
%
\noindent for each $j = 1, \ldots, n$ makes sure that we satisfy the joint limits both for the striking trajectory (at times $\upsilon_{j}^{1,2}$) and for the returning trajectory (at times $\upsilon_{j}^{3,4}$). We clamp the values $\vec{\upsilon}^{1,2}$ to the interval $[0, \, \hitTime]$ and $\vec{\upsilon}^{3,4}$ to $[0, \, \returnTime]$ if they are imaginary or outside their corresponding intervals. 

%Joint velocity and acceleration constraints $\dot{\joint}_{\mathrm{max}}, \ddot{\joint}_{\mathrm{max}}$, although not shown in \eqref{costFnc3}, can be enforced in a similar way. % add also cartesian constraints for the table

\subsubsection*{\textbf{Online Trajectory Generation}.} Using a constrained nonlinear optimizer, such as a sequential quadratic programming (SQP) based solver, we can run our algorithm online whenever we have enough ball samples $\numBallsMin \approx 12$ available to estimate the incoming ball reliably. After computing an initial striking trajectory and starting to move, we can correct the trajectories online whenever we have new ball samples available. 
%
\begin{algorithm}[t]
\begin{mdframed}
\small\sf%\centering
\caption{$\Alg$ ($\alg$)}
\label{alg1}
\begin{minipage}{0.95\linewidth}
\begin{algorithmic}[1]
   \Require $\joint_0, \ballLand, \landTime, \predTime, \returnTime, \numBallsMin, \vec{R}$ %\State {\bfseries Input:} 
   %\STATE Estimate model parameters from demonstrations
   \State Move to initial posture $\joint_0$, $\dot{\joint}_0 = \vec{0}$.
   \Loop
	   \State Query vision system for new observation $\ball$.
   	   \State Observe current state $\joint_{\mathrm{cur}}, \dot{\joint}_{\mathrm{cur}}$.
	   \If{$\numBallsMin$ new ball observations $\ball$}
	       \State Initialize EKF.
       \EndIf
       \If{EKF is initialized \algorithmicAnd valid obs. $\ball$}
	       \State Estimate position $\ball$ and vel. $\vec{v}$ with EKF.
		   \State Predict $\ballPred(t)$ till horizon $\predTime$.
		   \State \parbox[t]{\dimexpr\linewidth-\algorithmicindent}{Compute $\racketVel_{\mathrm{des}}(t), 			  \normal_{\mathrm{des}}(t)$ using racket 
			      model $\contactModel$ and boundary values $\ballLand, \landTime$.}
	   	   \State \parbox[t]{\dimexpr\linewidth-\algorithmicindent}{Compute striking and returning polynomial parameters $\joint_f, \dot{\joint}_f, T$ from current robot state $\joint_{\mathrm{cur}}, \dot{\joint}_{\mathrm{cur}}$ using desired resting posture $\joint_0$, time to return $\returnTime$, weighting matrix $\vec{R}$, and task constraints $\ballPred(t),\racketVel_{\mathrm{des}}(t), \normal_{\mathrm{des}}(t)$.}
		   \State \parbox[t]{\dimexpr\linewidth-\algorithmicindent}{Update strike and return trajectories $\joint_{\mathrm{des}}(t) = \{\joint_{\mathrm{strike}}(t), \joint_{\mathrm{return}}(t)\}$.}
	   \EndIf
	   \State \parbox[t]{\dimexpr\linewidth-\algorithmicindent}{Track $\joint_{\mathrm{des}}(t)$ with Inverse Dynamics $\vec{\tau} = \invdyn(\joint_{\mathrm{des}},\dot{\joint}_{\mathrm{des}},\ddot{\joint}_{\mathrm{des}})$.} % Execute
   \EndLoop
\end{algorithmic}
\end{minipage}
\end{mdframed}
\end{algorithm}

% TODO: TRY THE ALGORITHMICX PACKAGE!

The full trajectory generation framework and the resulting table tennis player is summarized in pseudocode format in Algorithm~\ref{alg1}. After bringing the robot to a desired initial posture $\joint_0$, the vision system is queried (line $5$) for new reliable ball position measurements. The Extended Kalman Filter (EKF) is initialized (line $8$) using the first $N \approx 12$ ball positions. EKF provides then with initial ball position and velocity estimates. This estimated ball state is updated whenever new ball measurements are available, and the updated ball state is used to predict the future ball path $\ballPred(t)$ up to a horizon of $\predTime$ seconds. Desired racket parameters $\racketVel_{\mathrm{des}}(t), \, \normal_{\mathrm{des}}(t)$ are computed (line $12$) for $0 \leq t \leq T_{\mathrm{max}}$ by inverting the racket model~\eqref{contactModel} and using the desired ball landing parameters $\ball_{\mathrm{land}}, T_{\mathrm{land}}$. 

Our optimization takes place online (line 13) whenever new reliable ball measurements and robot joint sensor recordings $\joint_{\mathrm{cur}}$ are available. The desired robot movement can be updated to accommodate for modeling and control errors. Feasible striking and return trajectories are then formed (line $14$), which are then executed with an existing inverse dynamics controller (InvDyn). In actual table tennis experiments, high gain PD-control is typically applied in addition to inverse dynamics. See Section~\ref{results} for more details of how we run our algorithm online in actual robot table tennis experiments.