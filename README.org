;; This buffer is for notes you don't want to save, and for Lisp
;; evaluation.  If you want to create a file, visit that file with C-x
;; C-f, then enter the text in that file's own buffer.

#-*- mode: org -*-
#+STARTUP: showall
#+TODO: WAITING TODO IN-PROGRESS DONE
#+TAGS: { @journal(j) @conference(c) @idea(i) @general(g) }

* Trajectory Generation in Table Tennis 			   :@journal:
** Writing/reading side: 
*** DONE Merge the two paper contents
*** DONE Update the Defensive Player version 
Removed the free rest time/rest joints criterion in Lazy Player and
made experiments with the q0-independent player.

Here we're considering another optimization where the resting state
posture is optimized based on the jacobian of the resting joint
posture and the previous incoming ball trajectory.

**** DONE Include penalty on jacobian of resting joints
**** DONE Include penalty based on incoming ball pattern?
*** DONE Update unit test Defensive Player results to MPC section
Discrepancy between unit test results and SL simulation results for
DEFENSIVE PLAYER (DP). In SL, DP can return most spinning balls (ball
mismatch case) after a few failed attempts at the start, whereas in
unit tests DP is much less successful (compared to FP).  What is the
problem here?

*** DONE Motivate the two players better
Guilherme's comment was that the two players introduced in the journal
were not connected. I write in the journal that 'a higher strategy'
could decide/switch between the two players as needed.
*** DONE Add more related work on Table Tennis
This was specifically asked by the first reviewer.
*** DONE Include more discussions for real robot experiments
The discussions focused more on the distribution of the ball landing
positions, DP distribution was shown to be wider (as it should be).
*** DONE Include table with parameter estimates for real robot
**** DONE Include spin model
I have decided to include the spin models since they make enough
difference in the real robot experiments
**** DONE Table with parameter values
Included a table with rebound model and free flight model parameters
** Theory side: 
*** DONE Go through Applied Optimal Control [Bryson&Ho]
Of particular interest is the section on perturbative feedback (rather
than solving HJB, only local feedback is generated).  This is the same
as LQR around a trajectory but with cross-terms coming from second
derivatives of the Hamiltonian

*** DONE Can we include free time optimization in HJB?
MP + Transversality conditions can be derived from (generalized) HJB
by including final time as another control variable.

The HJB is generalized in the sense that the equality constraints for
hitting the ball are enforced: the value function is not defined
otherwise
*** WAITING Incorporate table constraints in the optimization?
Incorporating cartesian constraints in a viable way seem to be quite
tricky.  It seems to check for the extrema values we would have to
check for the singularity of the Jacobian as well, i.e.,

If the Kinematics function is K(), we need to enforce K(q(t)) < x_lim
at all times t \in [0,T]!

To do that we can check for the endpoints q0 and qf AND enforce the
extrema values to be below x_lim. That is, solutions of J(q)q_dot = 0
should be always feasible. Checking this requires knowing when q_dot =
0 as well as when J(q(t)) = 0.

*** WAITING How can we solve MP with state constraints explicitly?
Including maximum joint limit constraint explicitly within MP should
be possible. For now we're only adding the extrema checking on top of
the unconstrained MP based algorithm.

More rigorously, the algorithm derived can be proved to converge to a
local optima using the Maximum Principle that assumes unconstrained
inputs and state space. What we need is a (constrained) MP that
accounts for the convergence of the full algorithm (that includes the
joint extrema checking).

**** WAITING Can the joint extrema checking be derived from constr. MP?
*** IN-PROGRESS Check KKT conditions 
For the Defensive Player the KKT conditions are satisfied by taking
derivatives of the augmented cost function. This should be checked
more carefully.
*** DONE Sufficiency of the optimization should be proved
Using HJB equation should provide us with sufficiency but the Value
Function is hard to find.  The strong Legendre-Clebsch conditions for
local optimality and the nonblowup of modified Ricatti matrix gives
local sufficiency conditions.
** Coding/SL: 
*** Coding in MATLAB
**** IN-PROGRESS Check punished Defensive Player in MATLAB [without MPC]
Coded the basic Lazy Player
**** WAITING Can we add MPC and a fast optimization loop with IPOPT?
**** WAITING Can we show the benefits of correction in MATLAB?
**** IN-PROGRESS Simplify kinematics function in MATLAB
Changed the math operations to matrix multiplications, doubled the
speed for polynomial optimization in MATLAB
***** IN-PROGRESS Kinematics function returns unnecessary matrices for calc_racket_state
*** Coding in C++
**** DONE Update documentation
Using doxygen to generate the documentation
**** DONE Organize SL code, introduce Armadillo
**** DONE KF in SL is broken
**** IN-PROGRESS Robustify Defensive Player 
1. Added finite differences + enabled GRAD based optimization routine in 
nlopt. Using AUGLAG + VAR2 (Augmented Lagrangian with variable metric
Quasi-Newton method)
2. Weighting does not seem to be too much of an issue.
3. Good initialization seems to be critical, hence using a LOOKUP TABLE 
from last year and KNN regression with k = 5
4. The landing constraint is discontinous, now only updating landing 
positions in the optimization if the landing time is positive
5. Using resting state optimization to find suitable rest postures
DP has problems converging.
***** WAITING Test over hundreds of tests
We can use the unit test that was asked by reviewer 1.
****** WAITING Add unit test with different initializations
I want to test if the algorithm can converge from any arbitrary
initialization. This is false I think since there were so many issues
in the online implementation.
***** WAITING Is it possible to remove/robustify LOOKUP TABLE and still optimize well?
***** WAITING Otherwise we can train 3 different lookup tables that are globally opt.
One each for RIGHT_SIDE, CENTER, LEFT_SIDE initial postures
***** DONE Refactor/organize calc_times of Defensive Player
***** DONE Read COBYLA
***** WAITING Calculating derivatives of calc_racket_state
****** WAITING Calculate analytical derivatives
I have created a unit test to test the analytical derivatives.  But I
could not make progress after a while, computing the derivatives of
the racket normal was not working (when compared with numerical
diffs).
****** WAITING Test automatic differentiation for derivatives of calc_racket_state
******* DONE Testing automatic differentiation for a simple kinematics function
******* WAITING Testing autodiff on a simpler 2D calc_racket_state function 
***** DONE Solve the simpler problem of touching the ball
Added a boolean variable land which if FALSE we only try to satisfy
hitting (and not landing) constraints This is an additional way to
debug the optimizer
***** DONE Solve with a derivative-based optimizer in NLOPT
Using numerical differentiation was possible with der. based solvers
in NLOPT, surprisingly (AUGLAG + VAR2 was the best performing)
***** WAITING Solve with an IPOPT optimizer
Computing also the derivatives either analytically or automatically is
required hence halting this branch

***** WAITING Test adding Tland as another optimization variable
Instead of using a discontinuous inversion to compute the landing time
as a discontinuous function of hitting time T and checking the landing
constraints at this Tland, why not include Tland as another
optimization variable?

**** DONE Resolve hitting time T becoming NaN in inter_ball function
**** WAITING Determine a normal from spin racket model
We introduced a spin racket model for the paper but how to determine a
(unique) ndes from the nonlinear spin racket model is not clear to me.
**** DONE Reorganize optimization algorithms
***** DONE Add class structure to optimization algorithms
***** DONE Read up on C++ inheritance
***** DONE Try removing legal ball detection
Added check_bounce option in the player configuration file, which if
disabled turns off legal ball detection (which is problematic for REAL
ROBOT experiments).
***** DONE Reduce racket/ball prediction time to below 2ms
Using -O3 optimization in player (release mode) reduced prediction
time to 0.2-0.3 ms from around 1.5-2.5 ms!
***** DONE Fix tabletennis class bug where after bouncing on robot side the ball is still counted as valid
***** DONE Remove the mode_operate enum and introduce detach and outlier detection booleans
***** DONE Organize the player and tabletennis class to avoid global variables
**** DONE Check correction in SL with spin model (for three algs) 
***** DONE Corrections in cheat mode are working
***** DONE Corrections in filter mode should be working
***** DONE Unit test to compare performance of three algs
- Two robots playing against each other would also be a good simulation
where FOCUSED player would play against LAZY player. However this is
not strictly necessary for the paper.
**** WAITING Add filtering also for the robot 
**** DONE Limit allowed accelerations, or velocities 
Crazy trajectories should never appear in simulation nor the real
robot
**** DONE Change to cmake
***** DONE Create simple hello world example with cmake
cmake_minimum_required, project, add_executable are the important
commands here

***** DONE Add include folder
Adding an include folder requires setting target_include_directories
when compiling a TARGET (in this case an executable).
include_directories (e.g. after adding a package like boost libraries)
adds to all the targets I think, hence should be used in the top level
cmake file.
***** DONE Add an external library
Adding an external library requires target_link_libraries command.
But the library should be in the systems usual library folders like
/usr /usr/local etc.  Otherwise the library has to be added with a
find_package() command or find_path, find_library commands [in case
find_package doesnt work]
***** DONE Add compilation options
Cmake is very flexible, compilation options can be usually set in many
different, sometimes equivalent ways. The best strategy could be to
set initially CMAKE_CXX_FLAGS_RELEASE and CMAKE_CXX_FLAGS_DEBUG flags.
Cmake should then be called with -DCMAKE_BUILD_TYPE=Release or Debug.

I was initially using the command target_compile_options.
***** DONE Include out-of-source build
Including out-ouf-source build is very easy and also recommended.  To
do so simply mkdir a build folder and call cmake from there: cmake ..
***** DONE Compile as shared object
The command to compiling as shared object is add_library(${TARGET}
SHARED ${SOURCES})
***** DONE Call shared object from test
Calling shared object from test requires again the
target_link_libraries command in the test/CMakeLists file.

Don't forget to add the library in LD_LIBRARY_PATH after make install.
***** DONE Add subfolder structure (include, src, test)
Adding a subfolder structure requires putting the relevant CMakeLists
files in the subfolders.
***** DONE Have release and debug versions independently
By creating release/ and debug/ folders in build/ and calling the
relevant compilation flags from there (e.g. CMAKE_CXX_FLAGS_RELEASE
for release/ folder) we can keep two different builds separate.

For exposing the library, the release shared object can be put to a
lib/ subfolder in the top repository folder by calling make install

***** DONE Require packages before compilation
Requiring packages before compilation is quite tricky, often
find_package(LIBRARY REQUIRED) fails. This command requires a
FindLIBRARY.cmake file if the system doesnt know the library (it knows
e.g. boost and armadillo libraries but not nlopt it seems)

After find_package finds the libraries the include folders need to be
added by calling include_directories(${LIBRARY_INCLUDE_DIRS})

If find_package doesn't work, find_path and find_library commands can
be used.

***** DONE Test with SL
Testing with SL didn't cause many issues.  ADOLC doesn't have a
find_package command, so we need to explicitly add its includes in
each cmake file I think.

***** DONE Test compilation in another computer
This worked well in my older laptop after a brief struggle.

In the robot computers, boost was loading the previous versions which
had a crazy incompatibility issue with one of the load()
functions. The string passed to the function was NULL, and was causing
crazy errors. This was resolved by again using find_path(),
find_library() cmake functions and specifying the paths explicitly.

**** DONE Move comments to header
**** DONE Add namespaces to avoid name-collisions
**** DONE Rename repository to table-tennis
**** DONE Introduce install script and organize folders
** Experiments:   
*** DONE Solve the problem of robot halting
Testing on the new computer + vision should settle the issue.  Thread
launching on Xenomai could also be an issue.
**** DONE Test with Valgrind (memcheck specifically)
There was a memory leak due to nlopt_destroy not being called in
multiple places.

*** WAITING Can we learn/test the more general racket-ball contact model?
**** WAITING Show it outperforms the reflection law
*** IN-PROGRESS Analyze collected real ball/sim robot data 
**** WAITING Filter after resetting every 300 ms should work?
It doesnt seem to work so well if the balls are coming fast Test maybe
another method (like difference to last ball observation) in
combination

In the experiments I was turning off the ball gun to avoid this
problem.

**** IN-PROGRESS Estimate initial ball spin
Estimating initial ball spin with 12 balls Using NLOPT + NEWTON type
method to optimize
***** DONE Add detach for real robot experiments
***** TODO How to make sure spin estimation is not overfitting?
***** DONE How to change the topspin constants for filter?
I added additional parameter input (besides the state) to the function
pointer of EKF class
**** WAITING Analyze reduction of error with a spinning ball model
**** DONE Adjust rebound model
1. Changed the table level to -0.90 from -0.95 (modified floor level to -1.66)
since the balls seemed to rebound much earlier!
2. Removed the modifiers that I was adding to alpha parameter
to predict better, I don't think they were helping (maybe overfitting
some examples)
3. Changed mu, dynamic coeff. of friction to 0.10. Helps predict much better
4. Rebound model was different in CPP vs. MATLAB. Now they are the same
5. Removed the roll version for bounce. It seems all balls slide.

**** WAITING Train ball models that account for spin
Jans suggestion: Look into data with an FIR filter and try to fix
number of samples
- Gaussian Process
- Local linear models
- Neural network
**** WAITING Collect new ball data
Ballgun should be oscillating and get a lot of balls for analysis
***** WAITING Compress the recordings?
*** WAITING Resolve issues with MPC
**** WAITING MPC is making aggressive corrections. How can we prevent that?
MPC is making too rapid corrections. Why?
***** WAITING Could minimizing jerk resolve this issue?
**** WAITING Prevent robot re-hitting balls that land on robot side
This seems to be happening when MPC is turned on.
*** IN-PROGRESS Check how long predict() takes in experiments
**** DONE predict_ball() doesn't need to predict for 2.0 secs long always
Reduced the prediction time 0.2-0.3 ms with -O3 flag (release mode)
**** TODO Check predict_ball() time with spinning ball model

* Two robots playing Table Tennis 				:@conference:
** IN-PROGRESS Test the new vision interface
*** DONE Compile vision code in laptop
This was a lot of work and took me one full day!

I needed to compile ball_tracking but it had too many dependencies.  I
downloaded Sebastian's repositories, and to compile them all I had to:

- Use find_path() and find_library() commands in cmake rather
than the find_package() commands which could not locate user specified
include and library paths automatically.

- Add the PvApi library. I found these (lib+includes) in google in a github repo.

- Install new version of libprotobuf from source. This is quite tricky as there
is an older protobuf library in Ubuntu folders and that should NOT be
replaced. The new libraries should be added in cmake with commands
mentioned above.

- Getting json.hpp from nlohmann's github (single include) did not work
as the version is too new. Some of the repositories are using json
v1.0 so this header should be copied uniformly throughout the repos.

- NLOPT should be compiled as a shared object. The new version in the github
repo includes a cmake file and compiles it as a shared object now.

- Add iostream headers in some repos (camera?) as they were not included
before.

*** DONE Compile vision code in vision computer
I'm using my own account to compile the vision.

The difference is that GPU will be used to track the ball (using then
CUDA libraries).

After talking to Sebastian, it seems I need to run at least the 2d
server in the vision computer (HELBE). So in any case I have to
compile all the code in HELBE as well. I need to also update the json
files with new versions that Sebastian uses.

The libs to be compiled are: ball_tracking, camera, robcpp, rob_protos
and robpy libraries. (this should be simplified later).

robcpp includes three libraries: lib_robotics, table_tennis, slpp.
They should also be compiled in that order.

Compilation notes:
1. libprotobuf library installation proved to be tough! This is 
because the Ubuntu system protobuf libraries are older versions
(protoc in particular was 2.6).

I had to first install it with --disable-shared and then install
protoc exe and the static protobuf libraries. I then had to enable
shared again and install the .so files. This however reverted somehow
the protoc exe back to 2.6!!! I then installed again with
--disable-shared to update protoc again back to 3.5.1!!

2. I made sure all the PATH, LD_LIBRARY_PATH, LIBRARY_PATH, 
LD_RUN_PATH, CPLUS_INCLUDE_PATH, C_INCLUDE_PATH are pointing to
/is/ei/okoc/install/include, lib or bin folders! Some of them might be
unnecessary!

3. When compiling rob_protos FindProtobuf.cmake file was creating
a big mess and initially loading the older protobuf library.  After
completing items (1) and (2) and setting:

set(Protobuf_DEBUG ON) set(PROTOBUF_PROTOC_EXECUTABLE
/is/ei/okoc/install/bin/protoc) list(APPEND CMAKE_MODULE_PATH
"${CMAKE_CURRENT_LIST_DIR}/cmake")
include_directories(${CMAKE_CURRENT_BINARY_DIR}) include(FindProtobuf)

(some of them are probably redundant) I speficied the newly installed
Protobuf shared libraries explicitly with the find_library, find_path,
include_directories commands.

4. Compiling camera was also quite tough. There was a very
obscure linkage error, which was apparently due to boost_log_setup not
being included.

I ended up installing boost v1.67 log,program_options,system,
filesystem in the computer. This was probably unnecessary.  The
previous versions were v1.58.

5. To link lib_robotics with shared nlopt library found in 
the system folders, I had to remove the explicit nlopt find_path,
find_library commands I was using before in my laptop. Instead I just
added FindNLOPT.cmake in a cmake subfolder and then used find_package
command.  NLOPT should then be linked with NLOPT_LIBRARIES command.

6. To link some example code of table_tennis folder
I had to additionally compile BOOST_THREAD. I then had to additionally
specify BOOST_LOG and BOOST_LOG_SETUP libraries for a particular
example target.

7. Compiling slpp was one of the hardest. There was a very
obscure error with protobuf library header not being found, which was
maybe because the slpp proto files were pre-generated before. Putting
the generated files from the rob_protos repo solved that issue.

As a minor issue, boost thread, system, log_setup libraries were not
added and one of the examples was giving an error.  Adding them in the
top cmake file using find_package with components option resolved the
issue.

8. Finally compiling ball_tracking was I guess the hardest.
Tracking the ball with GPU processing requires installing the library
with opencv and cuda libraries. The ubuntu opencv libraries that come
with apt-get do not have cuda installed. Hence I had to compile &
install opencv in the vision computer from source.

I installed opencv 4.0 with Release mode, with the extra modules, and
with fast-math enabled.

-D CMAKE_BUILD_TYPE=Release \ D
-CMAKE_INSTALL_PREFIX=/is/ei/okoc/install/ \ D WITH_CUDA=ON -D
-ENABLE_FAST_MATH=1 -D CUDA_FAST_MATH=1 \ D WITH_CUBLAS=1 \ D
-OPENCV_EXTRA_MODULES_PATH = ../../opencv_contrib/modules/ \ D
-BUILD_EXAMPLES=ON ..

I ended up using ccmake to specify these along with several other
options (lapacke directory, cuda specific architecture, see below)

Many CUDA libraries were already installed in a system-wide common
nvidia folder, and I chose cuda-9.1 as the cuda of choice.  Checking
with NVIDIA and using the "nvidia-smi" command in ubuntu revealed that
the GPU is GeForce GTX 1080 which if you check online is Pascal 6.1. I
then specified Pascal and 6.1 in separate options in ccmake.

While compiling, I specified make with -j8 option to compile it using
parallel processors, which makes a big difference when you compile big
projects like opencv.

Finally, after compiling opencv, ball_tracking and camera libraries
had to be recompiled! They were previously compiled with Opencv 2 and
opencv 3 is not fully compatible.  For instance, Opencv 3 dropped all
of the CV_ prefixes in some constants and added COLOR_ in several
(BayerGB2RGB I think).

9. GPU mode in ball_tracking was not working. There was a segmentation fault
which after debugging with valgrind revealed that cuda 9.1 was not
compatible with NVIDIA driver. Updating the driver to 396 (which is
compatible with the current GEFORCE GTX 1080 graphics card, I checked
in nvidia webpage) and rebooting solved the issue.

*** DONE Test vision code with a fixed ball
**** DONE Test with CPU in vision computer
Testing with CPU slows down the computer like crazy.
**** DONE Test with GPU in vision computer
Problem fixed after updating nvidia driver
**** DONE Test in desktop computer (SILL)
Connecting to helbe.
**** DONE Test in robot computer
*** DONE Test vision code with a flying ball
Testing on the PING side with both PING can PONG calibrations reveals
that the ball is detected very well even with oscillating ballgun if
the ballgun is at the centre. Putting the ballgun to the right side
however, we start seeing some detection failures.

I saved the python plot results due to different configurations
(ballgun center/right, calibration values PING/PONG) in robot computer
in okan_vision.
*** WAITING Keep code in a new repository
**** WAITING Simplify vision code
Reduce the dependencies foremost!  At least, robcpp and rob_protos
folders should not be required.

Vision experiments and training should ideally be part of the repo.
Python and C++ files should only be in the repo if they are actually
needed.
*** TODO Make sure to compile vision code in release mode
*** DONE Adapt interface code for new vision
**** DONE Write the new SL interface
I'm using ZMQ interface with the SUBSCRIBE pattern to communicate to
the vision server. A listener receives the json structure sent from 3d
vision server in a detached thread and a fetch() function retrieves
the latest ball data to the play() function.

Other than that I did not modify the previous code, e.g.  the
filtering methods, outlier detection, movement timing, etc.
**** DONE Test the new SL interface
Testing requires setting up also a publisher
**** DONE Test simulated robot with real ball
Tested on both ping and pong, of course with different ports 7660 and
7661 respectively.
** DONE Retrain ball detection model 
Using new data I retrained the parameters of a ball detection model.
I don't see any advantages however, the previous parameters are just as robust.
*** DONE Find/print saved model parameters after training
The test script test_ball_segm.py prints the logistic regression
parameters.
*** DONE Run test script
Running the test script allows us to evaluate the model on new
images. To evaluate loss on test images with labels, consult the
tensorflow loss usage in lin_log_reg.py.
*** DONE Label new data
I labeled the still ball data as well as one video where the ball is
flying over the table.
*** DONE Train with new labeled data
I figured out how to train with new labeled data. I had to modify the
script that loads the data with os.walk() in order to load the files
recursively. 
*** DONE Compare the parameters and performance in new data
Testing on 1/3 of the labeled new data, the performance of the model
trained in new data was not better than the performance of the model
trained with the old data!
*** DONE Learn where to copy the parameters
Parameters should be copied in the nonzero entries given by
cam_all_max_lin_srv_attached.json.
*** DONE Check cpp code for logistic regression
The logistic regression is implemented in tracker.cpp in the
CB_log_reg class.
*** DONE Test cpp code for ball detection
I added a new test script in tests/ folder where I load an image,
compute log likelihood, normalize, calculate probabilities and find
the key points. Showing the images after each operation as well.
*** DONE Compare performance 
New training does not seem to improve the performance.
**** DONE With new still data
**** DONE With recorded robot video frames
Since there are too many recorded images keeping the capacity to 100,
then shuffling the 100 images and then showing the first 5 images with
the detected ball.
** IN-PROGRESS Calibrate the vision
*** DONE Record a video with the cameras and analyze
It is possible to save images by running the multi_capture script.
One needs to specify the frequency of images to be saved (e.g. 1 means
save every image).
*** IN-PROGRESS Calibrate vision using robot data and images
**** DONE Align saved joint positions with video frames
One needs to check manually so far for the alignment of frames
which is easy since images are roughly 180 Hz and joint pos
are 500 Hz.
**** DONE Compare the existing calibration predictions 
Old calibration is off since the robot was moved
**** DONE Learn projection matrices with a linear method
Using the SVD analysis of the A matrix and taking the rightmost
singular vector corresponding to the smaller singular value
**** DONE Make new predictions on robot data and still balls
Using the new projection matrices I use a linear triangulation method
I compared it with the opencv triangulatePoints function and the
results are identical.

I have two functions that evaluate reprojection error on pixels
dataset and a custom error on the still balls.

The custom error checks for sensible distances between predictions
given the geometry of the table.

***** DONE Test with the new trained logistic regression params
Testing with the new trained parameters makes the method much more
robust when the net is occluding the balls.
**** WAITING Record new robot data with PONG
**** WAITING Predict on new PONG data and compare with old calibration
**** WAITING Check for undistortion of images 
A quick look at the images with Mehdi convinced us that there is not
much distortion (one should check the lines on the corners for
straightness).  Check PvAPI for c++ function to perform distortion
correction
**** WAITING Learn projection matrices after distortion correction
Compare with previous predictions.
***** WAITING Test the solvePnP function from opencv
So far it didn't improve the test/training accuracy of the calibration
matrices.
***** WAITING Test the custom nonlinear least squares code
Estimates also the distortion parameters, trying to minimize the
projection error.  Easily overfits to data.

***** WAITING Improve calibration with chess board pattern
Yasseen will work on this. 
Opencv calibrateCamera function requires a chessboard pattern 
but should produce superior results. Specifically, it should help
improve the generalization.
** IN-PROGRESS Test with simulated ball on both robots
*** DONE Run code in PING
When I tested the code with simulated ball, the code was printing
legal lands.
*** TODO Run code in PONG
*** TODO Check for tracking errors
Saving some of the movements to a file will help.
*** TODO Test with cheat function
This way we can check for the effect ball estimation is having
** IN-PROGRESS Add unit tests for two robots playing
*** TODO Add graphics
**** TODO Copy graphics from SL
**** TODO Add graphics for a second robot
*** IN-PROGRESS Reorganize/refactor code
**** DONE Add options to install script
Now the install script takes the test,debug and build flags.

--test: make and install the tests and run them
--debug: make but not install in debug mode

If make does not pass, tests are not run.
***** DONE Add argument for testing
By providing options to boost_unit_test in command line with
--run_test=TEST_SUITE where TEST_SUITE is one of
SL,OPT,KIN,KF,TT,SERVE or a comma separated combination of them we can
run particular suites.

***** DONE One cmake should build on the robot & mpi
cmake can now run as is in both mpi computer and also in my laptop.
Of course this is true because we set the LD_LIBRARY_PATH and other
paths correctly in the bashrc script.

Using ${Boost_XXX} instead of boost_xxx in cmake when compiling
library helped.

No need from now on for the --build flag.
**** IN-PROGRESS Build debug mode as well
The install script does not 'make install' if called in debug mode: -d

Setting excessive options like -Werror and -Weffc++ to try to ensure a
high quality of coding standards.  I had to add -Wno-error=effc++
since effc++ was added before c++11 and complains erroneously about
c++11 type default initialization.
***** TODO Unit tests do not pass the debug mode
The problem appears to be mostly due to the json library in debug
mode.
**** TODO Use json for loading settings/config
Instead of using armadillo load() function
**** TODO Refactor filtering code
boost program options can be replaced with either json or with
property trees
**** DONE Switch to shared nlopt lib
**** IN-PROGRESS Refactor/simplify interface
Old interface play() is not needed for instance
***** DONE Move listener class to ball_interface
***** TODO Add a zmq based sim code that simulates the ball
****** TODO Use same ZMQ interface written for real robot
****** TODO Call it from SL and check if it works
**** TODO Get rid of utils.cpp in optim code
Replace with armadillo based linear algebra
***** TODO Check timing of optim before/after
Replacement should not slow down the optimizations

**** TODO Parameterize robot startup 
Loading robot startup parameterization and table related constants
from a file would simplify the unit test for two robots playing
**** TODO Introduce boost log framework?
*** TODO Add table constraint in the unit test
The optimization should respect the table constraint always.
** TODO Test with two robots playing against each other
*** IN-PROGRESS Test real robot with real ball independently
***** DONE Test PING with vision
Using port 7660
***** IN-PROGRESS Test PONG with vision
Using port 7661, the real robot for some reason was not working, even
though simulation was working
*** TODO Add table constraint in the optimization

*** TODO Can we start gameplay with a serve?
* Learning To Serve 						   :@journal:
** Reading/Writing
*** Reading
**** TODO Check out new papers on deep RL for robotics 
Sergey Levine and Pieter Abbeel's new papers come to mind.
Especially: TRPO, Guided Policy Search, ...
***** TODO Read Latent Space Policy Search
Kevin Down et al. Compare with Bayes Opt approaches.
***** TODO Read Massive Uninformed Search vs RL
Benjamin Recht et al.

*** Writing
**** TODO Better plot for the Elastic Net path
Include in the paper an Elastic Net path using LARS that makes more sense.

**** TODO Add an example of a learned ranking
with basis function parameters that illustrate the importance of the learned
movement primitive.
**** TODO More discussion of Alg2 optimization procedure
The algorithm selects very different parameters (even the number!) depending
on the initial starting widths, heights, etc.
**** TODO Plot sample pruning path
Include plot of how the algorithms remove some of the variables, i.e.
87-80-70-70-... on average
** Theory
*** WAITING Learn invariants of motion/policy from demonstrations
The idea is to learn invariants of motion / parameterize the relative
motion between the joints using a graph (graphical model?).

The improvement for RL is to find a reduced dim. latent space on which
we can perform policy search/BO.

**** WAITING Learn a policy that depends on joint state and ball state
The policy that the graph generates is relative, i.e. it can be
grounded by specifying an initial joint state and possibly also ball
state.

Ideally the policy should also have low accelerations and ideally it
should involve some sort of planning, e.g. it should know
intrinsically the value of a certain distance from the ball.

**** WAITING Learn a policy that understands the intention of the teacher
Inverse Reinforcement Learning maybe? To learn the Value Function
of the teacher?

*** TODO Can we learn a model of the ball takeoff?
Possibly from movement primitives and/or RL trajectories one could
learn such a model.
*** TODO Can the traj generation be solved with polynomials?
Does the full planning problem with the two ball takeoff and racket
impact models included result in a continuous trajectory? hybrid?
polynomials?
*** TODO Check local perturbative feedback solutions
If we can additionally solve for local feedback, then one does not
need to optimize repeatedly 3rd/5th order 
*** TODO Reinforcement Learning
**** WAITING How to apply model-free RL
**** TODO How to apply model-based RL
The approach must clearly be model-based as I do not want to have 'N'
rollouts for each policy $\theta_k$.

As opposed to GPs or neural networks, we could first try local linear
models as an extension of DMPs.
***** TODO Learn model of what?
Model for the ball take-off, ball-racket impact or robot dynamics? Or
all three? Couple the ball as part of the state as well?
***** TODO Is the ball or the robot rest posture a context?
We have to make sure that local policy generalizes to different ball
positions and robot rest postures.

**** IN-PROGRESS How to apply BO
In high dimensional cases it seems important to do dimensionality
reduction.

The initial posture of the robot corresponds to the 'context' of the
problem and contextual bandits would learn a GP over the contexts as
well.
***** DONE How to do dimensionality reduction on policy params
Jan suggested performing PCA analysis first but in the end 
I proposed (Lasso-like) multi-task Elastic Net coupled with feature
adaptation.
***** TODO Check out latent space approaches to BO
The recent BO survey should be of help.
***** TODO Read the recent gradient based BO paper in NIPS last year
***** TODO Investigate hierarchical approaches to Bayes Optimization
UCT algorithm comes to mind

** Simulations
*** DONE Add unit test with optimization
New serve() function in SL can perform an optimization whenever the
movement is predicted to fail. The movement will then switch the
optimization if a feasible solution is found.

- Added optim, detach flags
- Input q_act is parameter to initialize the optimization
- Rate of optim and other flags from player.cfg are replicated in
  serve.cfg 
- Desired land location flag also imported from player.cfg

*** DONE Calculate derivatives of movement primitive cost function
Check the python code for the derivatives
**** DONE Test derivatives
Added pytest in Python to check for derivatives
**** DONE Add Elastic Net path after LSDP 
Generated Elastic Net path after training (coupled) LSDP parameters
*** TODO Policy Search review
We have rl-experiments/ repository where I include
the REINFORCE algorithm that I emplemented

The MIPS MATLAB Policy Search and iLQG MATLAB code is also 
included.

**** IN-PROGRESS Check RL in MATLAB
***** TODO Test Power in MATLAB
using Jens Kober's implementation
****** TODO Adapt to my own DMP implementation
****** TODO Add an internal system
e.g. a Barrett WAM forward dynamics
****** TODO Increase dimensions of the state
***** TODO Add Reps in MATLAB
***** IN-PROGRESS Check Simone's RL toolbox (mips)
***** TODO Test against a realistic mismatch scenario
****** TODO Compare against ILC?
******* TODO Extend ILC with improved trajectories
As we use ILC and update the models, the models can also be used to
update the reference trajectories progressively.
******** TODO Relation to DDP?
**** TODO Check reinforce for convergence
REINFORCE is not converging!
***** TODO Test gradients
***** TODO Test calc_log_der 
Calculates the log derivatives 
***** TODO Test baseline subtraction
***** TODO Test against LQR solution (as baseline?)
***** TODO What are the effects of the hyperparameters?
Learning rate, policy structure, number of basis functions,
obs. noise, etc.
***** TODO Implement adaptive learning rates for reinforce
**** TODO Extend library with other policy search algorithms
**** WAITING Add interface to MUJOCO
**** TODO Read up on deep reinforcement learning blog post
** Experiments
*** DONE Hold the ball on the racket with an egg-holder
Heiko 3d-print-ed an egg holder for me to try
*** DONE Learning from Demonstrations
I'm trying at the moment to record ball positions as well during the
recordings.

The demonstrations are now shown in the new BORIS SL
(sebastian/sl_xeno/sl_wam)
with mass = 0.375 and mcm = 0.0! 
These are not optimal parameters at all! However after the racket
holder change, this was the best setting without the PD control that I
found. 

**** DONE Can we teach the robot how to serve
With the egg-holder it is possible to teach, but the shoulder is as
suspected difficult to move, even with the PD turned off.  I was
moving more the elbow so far.
**** DONE Can we learn/extract movement primitives?
***** DONE Record movement in gravity compensation mode
PD should be switched off.
***** DONE Extract movement primitives
Extracting movement primitives with 5 examples so far.  One can
remove/add more examples and also basis functions to test on the
robot.
***** DONE Test on robot
Testing on the robot was tricky, as we need to make sure that during
the kinesthetic teachin, the joint limits are never exceeded.  It
seems that the hardware limits are not the same as the software
limits.

After teaching for the second time with the eggholder on the red side
of the racket, the movement could be executed on the robot.

**** DONE Get ball positions during the teaching
*** DONE Tune the DMPs
We should have a json file with additional settings that we can
adjust.
**** DONE Pretty format the JSON file
MATLAB dumps the JSON file in an unreadable way.  Opening in Python
and formatting solves the problem.
**** DONE Adjust timing of the motion
Unit test added that checks if subsampling the sped-up signal restores
it to the original movement.

Silly mistake found where qd_des, qdd_des were not updated!
**** DONE Train on different examples in the dataset
Having multiple json files could easily solve this problem.
**** DONE Start on different initial conditions
Testing different postures, different DMPs and different starting
positions we see that the I.C changes the accelerations like crazy!
**** DONE Resolve the problem of high initial accelerations
Jens idea to reduce the initial accelerations does not work
unfortunately. Instead we can penalize the accelerations using Radial
Basis Functions.
***** DONE Penalize the accelerations throughout
This actually generates smoothing splines in the nonparametric case
and in the parametric case when we also put an l1 penalty on the
parameters we get a (multitask) Elastic Net!

*** TODO Test the sparse RBFs on real robot
Testing the learned sparse RBFs on real robot is next.
*** IN-PROGRESS Test ball information
**** DONE Test ZMQ interface during human demonstrations
***** DONE Copy new trained vision parameters to json files
The new logistic regression parameters must all be negative.
I saved the projection matrices also in a serve_3d_ping_okan file. The
matrices are not normalized (i.e., P[3,4] is not 1) but triangulation
in c++ does not cause a problem.
***** DONE Add 2d interface to listener
Instead of running an external triangulation server, I can do the
triangulation in a detached thread inside the table tennis library.
****** DONE Add triangulation method
In Python I use SVD to solve for the rightmost singular vector, this
is a linear triangulation method.
***** DONE Test online with demonstrations 
It is easy to debug the interface, I can stream the received 2d pixels
and the triangulated 3d positions to a debug file online
**** IN-PROGRESS Questions about ball interface
***** TODO How to use time stamp?
I use now the num variable received from the vision server
***** TODO Why so many files depend on ball_interface?
If the header changes almost all the library recompiles
***** TODO Should saved proj. matrices be normalized?
So far triangulation did not pose a problem
***** TODO How to invert projection matrices in test
The linear triangulation method with SVD does not work in test.
Instead least squares with P0[1:2,:] and P1[1:2,:] rows concatenated
matrix gives the exact inverse in test.
***** DONE No need to send zeros if ball is not detected
This will obviously pose a problem online. Instead now I update the
ball positions only if triangulation succeeds.
**** TODO Test ZMQ interface during robot serve
**** IN-PROGRESS Plot ball and robot data during serve
Checking the ball data in python, we observe that the balls disappear
during the motion if the movement starts in the back, should be closer
to the cameras.

The zeros received in the ball positions are removed and the balls are 
plotted via the timing with the joints. [We get absolute time both
from joint positions and ball positions saved]
***** TODO How does the ball filtering look like?
***** DONE Does serving closer to the table help detection?
Yes it does!
**** TODO Listen2D flag is buggy after resetting (pressing 'f')
*** TODO Test optimization with movement primitives
Even if the ball-takeoff model is not known, one can use movement
primitives for at least the first part of the movement.
**** DONE When to optimize?
I think when it is clear that the racket will not return the separated
ball one can 'fire' the optimization.
**** TODO Compare third order to fifth order on robot
Third order or fifth order (minimum jerk)? Which is better?
***** TODO Is it necessary to do MPC?
I would guess fifth order should be better in this case
*** IN-PROGRESS Use Reinforcement Learning to improve execution
The Desiderata for RL in robotics:
1. Data efficiency
- no rollouts
- this implies model based or something in between (BayesOpt.?)
2. Safety
- small and/or local perturbations
- model based is more promising
3. Reward engineering
- unsupervised learning?
- reward shaping?
- building models on trajectories
4. Parameterized policies
- starting overparameterized or underparam.
- relation to ILC as a result of optim.

**** TODO What is the reward function to use?
The possibilities are:

1. Minimum distance between the ball and the racket during movement
2. Minimum distance between the ball and the robot court center
3. Maximum y-velocity of the ball

or possibly a combination of the above.
***** TODO Can we adapt the reward function?
Reward shaping comes to mind here.
* Cautious Trajectory Generation 				      :@idea:
** WAITING Maximize probability of landing as a new cost function. 
*** Which framework is suitable for solving it?
Stochastic Minimum Principle should be used as the framework of
choice.
*** Is there an algorithm for it?
Which stochastic MP generates the cautious trajectories that would
satisfy me?

** WAITING How can we introduce adaptation within this robust framework?
*** WAITING Plot tradeoff curve for ball-info vs. accelerations
Jan suggested at some point while going through the first journal
draft to show the trade-off curve for the initialization of trajectory
generation optimization process:
1. we estimate ball state better with more ball observations
2. we can hit with less accelerations if we start earlier

The stochastic optimal control based trajectory generation approach
could strike a balance between the two.
*** Reduce variance of predictions as we update the models?

